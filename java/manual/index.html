<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
    <link rel="icon" href="images/botball.ico" type="image/x-icon">
    <link rel="shortcut icon" href="images/botball.ico" type="image/x-icon">
	<style type="text/css">
		@import "style.css";
	</style>
    <title>CBCJVM Programmers Manual</title>
  </head>
  <body>
	Version 0.1, by Braden McDorman (bmcdorman@kipr.org)
    <br />
    <h1>CBCJVM Programmers Manual</h1>
	<center><img src="CBCJava_64.png"></img></center>
    <br />
	<p>
		This document assumes you have a decent understanding of Java and CBC development in C. CBCJVM is an Object Oriented library for CBC development in Java.
		Started in 2009 as an open source project, the project quickly grew as students and professionals contributed to its codebase.
		Now, after years development, CBCJVM has been included in the official CBC firmware.
	</p>
	<p>
		Java and CBCJVM allow rapid and professional development of robot programs. This document hopes to serve as a guide to understanding CBCJVM and it's usage.
	</p>
	<h2>Motors (<code>cbccore.motors.Motor</code>)</h2>
	<p>
		Individual motors are creating instances of the <code>cbccore.motors.Motor</code> class. The <code>Motor</code> class has a significant amount of similarity
		to libcbc. For example, if we wished to move motor on port 0 at a specific velocity for 1 second, 
		we could use the <code>moveAtVelocity</code> method in <code>Motor</code>.</p>
<pre><code><font class="Keyword">import</font> cbccore.motors.Motor;

<font class="Keyword">public class</font> MotorTest {
	<font class="Keyword">public static void </font>main(String[] args) {
		Motor test = <font class="Keyword">new</font> Motor(0);
		test.moveAtVelocity(150);
		<font class="Keyword">try</font> {
			Thread.sleep(1000);
		} <font class="Keyword">catch</font>(InterruptedException e) {
			e.printStackTrace();
		} 
		test.off();
	}
}</code></pre>
	<p>If you've programmed a CBC in C before, the method <code>moveAtVelocity</code> should look somewhat familiar. In C, we can use the <code>move_at_velocity</code> or 
		<code>mav</code> functions to achieve a similar effect. In CBCJVM, though, we don't have to supply a port to the method. The <code>Motor</code> class stores the port we supplied
		to it in the constructor, cleaning our code both syntactically and conceptually.
	</p>
	The next bit of code sleeps for one second (1000 milliseconds.)
	<pre><code><font class="Keyword">try</font> {
	Thread.sleep(1000);
} <font class="Keyword">catch</font>(InterruptedException e) {
	e.printStackTrace();
}</code></pre>
	<p>
		While this code is somewhat verbose, this is the standard way to "sleep" for a given amount of time in Java. As such, we will continue to use it in this manual. If you wish,
		you may encapsulate this code in a separate method to clean up your logic.
		However, most code in CBCJVM is reaction based, so sleeping occurs less often than one may think in nontrivial samples.
	</p>
	<p>
	A full listing of methods provided by <code>cbccore.motors.Motor</code> can be found in CBCJVM's doxygen documentation.
	</p>
	<h2>Servos (<code>cbccore.motors.Servo</code>)</h2>
	<p>Servos are also very simple to use in CBCJVM. In the following example, we will quickly move a servo on port 0 to position 500, then smoothly move it to 1000 over a period of 5 seconds. CBCJVM does quite a bit of work behind the scenes to accomplish this for us.</p>
<pre><code><font class="Keyword">import</font> cbccore.motors.Servo;

<font class="Keyword">public class</font> ServoTest {
	<font class="Keyword">public static void </font>msleep(long ms) {
		<font class="Keyword">try</font> {
			Thread.sleep(ms);
		} <font class="Keyword">catch</font>(InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	<font class="Keyword">public static void </font>main(String[] args) {
		Servo test = <font class="Keyword">new</font> Servo(0);
		test.enable();
		test.setPosition(500); // Move servo to 500 like in C
		msleep(1000); // Wait one second
		test.setPositionTime(1000, 5000, true); // Use CBCJVM to smoothly move servo to a new position over 5 seconds
		test.disable();
	}
}</code></pre>
	<p>Let's take a closer look at <code>setPositionTime</code>. CBCJVM defines the method like this: <code>setPositionTime(int newPos, int ms, boolean blocking)</code>.
		The first parameter is the new absolute position of the servo, just as in <code>setPosition</code>. The next parameter is the time to move over, in milliseconds. The next parameter is called <code>blocking</code>. In programming, a function is blocking if it waits for its operation to finish. For example, if we were to write a sample program to compute the value of pi, we might write the following:
<pre><code><font class="Keyword">public class</font> ComputePi {
	<font class="Keyword">public static void </font>main(String[] args) {
		System.out.println("Computing Pi...");
		computePi();
		System.out.println("Done!");
	}
}</code></pre>
	<p>Realistically, this function might take a significant amount of time to finish its computation. In the <b>blocking</b> scenario, the text "Done!" wouldn't print until the calculation finished. However, if the method is <b>nonblocking</b>, "Done!" will print immediately. A blocking function halts execution until it is finished, while a nonblocking function allows execution to continue. In both cases, pi will be computed, but in the nonblocking scenario we don't wait for it to do so.</p>
	<p>Since both scenarios have their obvious uses, CBCJVM allows the programmer to pick. In our example, we block. Otherwise, we would be disabling the servo before the servo finished moving, which wouldn't produce the desired behavior.</p>
	<h2>Sensors (<code>cbccore.sensors.*</code>)</h2>
	<p>CBCJVM sensors are slightly less straightforward than what we've learned so far. Sensors are based off of two core abstractions, that of the 
		<code>IBooleanSensor</code> and the <code>IAnalogSensor</code>. All other sensors and sensor decorators are based off of these two classes. For now, we will discuss the two of them separately.</p>
	<h3>Boolean Sensors (<code>cbccore.sensors.digital.IBooleanSensor</code>)</h3>
	<p>A Boolean sensor can be defined very simply: Anything that can return a true or a false. The method we call to determine this state is called <code>getValue</code>. All digital sensors fall under this category, so we will discuss them first. In the following example, we will wait for a touch sensor on port 15 to be pressed before printing a message.</p>
<pre><code><font class="Keyword">import</font> cbccore.sensors.digital.*;

<font class="Keyword">public class</font> TouchSensors {
	<font class="Keyword">public static void </font>main(String[] args) {
		Touch sensor = <font class="Keyword">new</font> Touch(15);
		<font class="Keyword">while</font>(!sensor.getValue()) Thread.yield(); // Wait until sensor is pressed
		System.out.println("Touched!");
	}
}</code></pre>
<p>You may be wondering what <code>Thread.yield</code> does. Why didn't we just use <code><font class="Keyword">while</font>(!sensor.getValue());</code>? To understand why, let's take a look at a slightly more complicated scenario. Let's say that CBCJVM was smoothly moving a servo for you, and you chose to continue code execution (nonblocking.) CBCJVM is able to do this by running a thread called <code>ServoThread</code> in the background, which updates the servo on your behalf. Now your program has two "threads" of execution. One of these is your main method, and the other is the ServoThread. If we simply do <code><font class="Keyword">while</font>(!sensor.getValue());</code>, we've effectively locked out other threads from using the processor. As a result, servo movement will be anything but smooth. Since the thread updating the servo on our behalf can no longer do its job, the servo will move in a sporadic manner. <code>Thread.yield</code> solves this issue by effectively telling Java we aren't doing anything important, so give the processor to another thread. Our <code>ServoThread</code> continues to run as a result, and our servo smoothly moves to where we told it! This is a good habit to get into.</p>

  </body>

</html>
